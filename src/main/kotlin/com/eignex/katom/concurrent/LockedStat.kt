package com.eignex.katom.concurrent

import com.eignex.katom.core.*
import java.util.concurrent.locks.ReentrantReadWriteLock
import kotlin.concurrent.read
import kotlin.concurrent.write

fun <R : Result> SeriesStat<R>.locked() = LockedSeriesStat(this)
fun <R : Result> PairedStat<R>.locked() = LockedPairedStat(this)
fun <R : Result> VectorStat<R>.locked() = LockedVectorStat(this)

class LockedSeriesStat<R : Result>(private val delegate: SeriesStat<R>) :
    SeriesStat<R> by delegate {
    private val lock = ReentrantReadWriteLock()

    override fun update(value: Double, timestampNanos: Long, weight: Double) {
        lock.write { delegate.update(value, timestampNanos, weight) }
    }

    override fun merge(values: R) {
        lock.write { delegate.merge(values) }
    }

    override fun reset() {
        lock.write { delegate.reset() }
    }

    override fun read(timestampNanos: Long): R {
        return lock.read { delegate.read(timestampNanos) }
    }
}

class LockedPairedStat<R : Result>(private val delegate: PairedStat<R>) :
    PairedStat<R> by delegate {
    private val lock = ReentrantReadWriteLock()

    override fun update(x: Double, y: Double, timestampNanos: Long, weight: Double) {
        lock.write { delegate.update(x, y, timestampNanos, weight) }
    }

    override fun merge(values: R) {
        lock.write { delegate.merge(values) }
    }

    override fun reset() {
        lock.write { delegate.reset() }
    }

    override fun read(timestampNanos: Long): R {
        return lock.read { delegate.read(timestampNanos) }
    }
}

class LockedVectorStat<R : Result>(private val delegate: VectorStat<R>) :
    VectorStat<R> by delegate {
    private val lock = ReentrantReadWriteLock()

    override fun update(vector: DoubleArray, timestampNanos: Long, weight: Double) {
        lock.write { delegate.update(vector, timestampNanos, weight) }
    }

    override fun merge(values: R) {
        lock.write { delegate.merge(values) }
    }

    override fun reset() {
        lock.write { delegate.reset() }
    }

    override fun read(timestampNanos: Long): R {
        return lock.read { delegate.read(timestampNanos) }
    }
}
